<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WSL on Alejandro Inglés Martínez</title><link>https://aleingmar-pi-portfolio.duckdns.org/es/tags/wsl/</link><description>Recent content in WSL on Alejandro Inglés Martínez</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Mon, 01 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://aleingmar-pi-portfolio.duckdns.org/es/tags/wsl/index.xml" rel="self" type="application/rss+xml"/><item><title>Despliegue de servicio web con EC2 AWS</title><link>https://aleingmar-pi-portfolio.duckdns.org/es/p/aws-ec2-assb/</link><pubDate>Mon, 01 Jan 2024 00:00:00 +0000</pubDate><guid>https://aleingmar-pi-portfolio.duckdns.org/es/p/aws-ec2-assb/</guid><description>&lt;img src="https://aleingmar-pi-portfolio.duckdns.org/p/aws-ec2-assb/aws-ec2.png" alt="Featured image of post Despliegue de servicio web con EC2 AWS" /&gt;&lt;p&gt;Este proyecto fue desarrollado para un trabajo de la asignatura Arquitecturas de Sistemas y Sistemas Distribuidos (ASSB) durante mi cuarto año de carrera. El objetivo principal era desplegar un servicio web funcional en un entorno en la nube utilizando los servicios de &lt;strong&gt;AWS&lt;/strong&gt;, manteniéndonos dentro de los límites del plan gratuito.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;El servicio web desplegado se conforma por un balancedor de carga que distribuye las solicitudes entre dos instancias de EC2, cada una con su propio servidor Apache y página web.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Las principales tareas realizadas incluyeron:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Control y creación de alertas de costes&lt;/strong&gt;: Configuración de alertas en AWS para asegurar que todas las operaciones se ajustaran al plan gratuito, evitando cargos adicionales no deseados.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Despliegue de instancias EC2&lt;/strong&gt;: Levantar dos instancias de &lt;strong&gt;EC2&lt;/strong&gt; y conectarnos a ellas mediante &lt;strong&gt;SSH&lt;/strong&gt;. En cada una de las instancias, instalar el servidor web &lt;strong&gt;Apache&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Configuración de servidores web Apache&lt;/strong&gt;: Configuración de los servicios de Apache en ambas instancias para que sirvieran una página web estática creada por mi mismo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implementación de un balanceador de carga&lt;/strong&gt;: Despliegue de un balanceador de carga en AWS para distribuir de manera equitativa las peticiones entrantes entre los dos servidores Apache, optimizando la carga y asegurando una mayor disponibilidad.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="link" href="../../../post/aws-ec2-assb/assb-aes-ec2.pdf" &gt;&lt;strong&gt;Visualizar memoria en pdf&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Computación paralela en sistemas distribuidos con MPI.</title><link>https://aleingmar-pi-portfolio.duckdns.org/es/p/mpi-assb/</link><pubDate>Wed, 01 Nov 2023 00:00:00 +0000</pubDate><guid>https://aleingmar-pi-portfolio.duckdns.org/es/p/mpi-assb/</guid><description>&lt;img src="https://aleingmar-pi-portfolio.duckdns.org/p/mpi-assb/mpi-logo.png" alt="Featured image of post Computación paralela en sistemas distribuidos con MPI." /&gt;&lt;p&gt;Este proyecto fue desarrollado para la asignatura Arquitectura de Sistemas y Software de Base (ASSB), durante mi cuarto año de carrera. El objetivo principal era familiarizarse con la programación paralela en computadores de memoria distribuida utilizando la &lt;strong&gt;librería MPI&lt;/strong&gt; en &lt;strong&gt;C&lt;/strong&gt; (Message-Passing Interface). Una técnica muy utilizada para la computación distribuida en múltiples máquinas, comúnmente utilizado en clústeres de alto rendimiento. En el caso de este proyecto todo se ejecutó en mi propio computador, entendiendo mi computador como una especie de clúster y sus diferentes núcleos como máquinas que forman este.&lt;/p&gt;
&lt;p&gt;Las principales tareas de este proyecto son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Desarrollo del programa de &amp;ldquo;Hola Mundo&amp;rdquo; con MPI&lt;/strong&gt;: Como primer paso, programé un programa básico para que &lt;strong&gt;cada proceso imprimiera un mensaje con su rango y el nombre del procesador en el que estaba ejecutándose&lt;/strong&gt;. Además, experimenté con la posibilidad de lanzar más procesos que el número de núcleos físicos disponibles, observando cómo MPI gestiona este escenario aunque pierda rendimiento.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Producto escalar de vectores en paralelo&lt;/strong&gt;: Implementé un programa con MPI que &lt;strong&gt;calcula el producto escalar de dos vectores&lt;/strong&gt; de gran tamaño, distribuyendo el trabajo entre varios procesos. Cada proceso calculaba una parte del producto escalar, y luego los resultados se reunían en el proceso de rango 0, que mostraba el resultado total. También se añadió una medición del tiempo de ejecución, lo que permitió analizar cómo variaba el rendimiento al cambiar el número de procesos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Resolución de integrales con el método de los trapecios&lt;/strong&gt;: Posteriormente, &lt;strong&gt;implementé un programa para calcular integrales mediante el método de los trapecios&lt;/strong&gt;, paralelizando el programa para que cada proceso calculara la suma de los trapecios en un subintervalo específico. Al igual que antes, el proceso de rango 0 era responsable de sumar los resultados de todos los procesos y mostrar el valor final de la integral.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Análisis de rendimiento y escalabilidad&lt;/strong&gt;: Para evaluar el rendimiento del programa paralelo, medí los tiempos de ejecución y la aceleración al utilizar diferentes cantidades de procesos, desde 1 hasta más del doble del número de núcleos físicos disponibles. Los resultados se visualizaron mediante gráficos que mostraban cómo la aceleración mejoraba conforme aumentaba el número de procesos, pero también cómo disminuía la eficiencia en ciertos puntos debido a la sobrecarga en la comunicación entre procesos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Documentación del proyecto: &lt;a class="link" href="../../../post/paralelizacion-mpi-assb/ASSB-mpi.pdf" &gt;&lt;strong&gt;Visualizar documentación en pdf&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Computación paralela en procesadores multinúcleos con OpenMP.</title><link>https://aleingmar-pi-portfolio.duckdns.org/es/p/openmp-assb/</link><pubDate>Sun, 01 Oct 2023 00:00:00 +0000</pubDate><guid>https://aleingmar-pi-portfolio.duckdns.org/es/p/openmp-assb/</guid><description>&lt;img src="https://aleingmar-pi-portfolio.duckdns.org/p/openmp-assb/openmp-logo.png" alt="Featured image of post Computación paralela en procesadores multinúcleos con OpenMP." /&gt;&lt;p&gt;Este proyecto fue desarrollado durante la asignatura de Arquitectura de Sistemas y Software de Base (ASSB) durante mi cuarto año de carrera. El objetivo principal era implementar un algoritmo para el cálculo del número Pi utilizando el método de MonteCarlo programando en C tanto de forma secuencial como utilizando técnicas de programación paralela para aprovechar al máximo los recursos de los procesadores multinúcleo mediante la librería OpenMP, que permite ejecutar código en múltiples hilos de manera eficiente.&lt;/p&gt;
&lt;p&gt;Las principales tareas realizadas fueron las siguientes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Desarrollo de la versión secuencial y paralela del algoritmo&lt;/strong&gt;: Implementé un programa que simula el lanzamiento de &amp;ldquo;dardos&amp;rdquo; aleatorios dentro de un cuadrado inscrito en un círculo. La relación entre los aciertos dentro del círculo y los lanzamientos totales permite calcular el valor de Pi. En la versión paralela, utilicé OpenMP para dividir el trabajo entre varios hilos, aprovechando al máximo los recursos de los procesadores multinúcleo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mediciones de tiempo y análisis de rendimiento&lt;/strong&gt;: Tras desarrollar las dos versiones del programa, realicé mediciones de tiempo para evaluar el rendimiento de la versión paralela en comparación con la secuencial. Utilicé diferentes configuraciones de hilos, desde un solo hilo hasta más del doble de los núcleos físicos del procesador, con el objetivo de analizar la aceleración y escalabilidad del algoritmo. La aceleración se calculó como la relación entre el tiempo de ejecución en un único hilo y el tiempo de ejecución con varios hilos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Optimización y gestión de recursos compartidos&lt;/strong&gt;: Durante el desarrollo, fue necesario resolver problemas comunes de la programación paralela, como las condiciones de carrera. En este caso, utilicé directivas de OpenMP para definir variables privadas en cada hilo, evitando que varios hilos accedieran simultáneamente a las mismas variables globales y afectaran el resultado final.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Generación de gráficos de rendimiento&lt;/strong&gt;: Tras recopilar los datos de tiempos de ejecución y aceleración, generé gráficos para visualizar el rendimiento del programa a medida que aumentaba el número de hilos. Estos gráficos demostraron cómo la aplicación escalaba con un mayor número de hilos, destacando las ventajas y limitaciones de la paralelización en un entorno de memoria compartida.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Documentación del proyecto: &lt;a class="link" href="../../../post/paralelizacion-openmp-assb/ASSB-openmp.pdf" &gt;&lt;strong&gt;Visualizar documentación en pdf&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Implementación de una Arquitectura Segura Cliente-Servidor en Java utilizando TLS</title><link>https://aleingmar-pi-portfolio.duckdns.org/es/p/seguridad-gasca/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://aleingmar-pi-portfolio.duckdns.org/es/p/seguridad-gasca/</guid><description>&lt;img src="https://aleingmar-pi-portfolio.duckdns.org/p/security-gasca/java3.png" alt="Featured image of post Implementación de una Arquitectura Segura Cliente-Servidor en Java utilizando TLS" /&gt;&lt;p&gt;Este proyecto fue desarrollado durante la asignatura de Seguridad, Confidencialidad y Gestión de la Identidad (SCGI) durante mi tercer año de carrera. Este proyecto se centró en el diseño y desarrollo de una arquitectura cliente-servidor segura utilizando el protocolo Transport Layer Security (TLS), con el objetivo de asegurar la confidencialidad, integridad y autenticidad de las comunicaciones.&lt;/p&gt;
&lt;h2 id="contexto-y-objetivo"&gt;Contexto y Objetivo
&lt;/h2&gt;&lt;p&gt;El proyecto surgió de la necesidad de asegurar las comunicaciones en una aplicación que permitiera la transmisión de datos sensibles, como credenciales de usuario (login/password), entre clientes y un servidor central. Este tipo de aplicaciones es especialmente relevante en entornos donde la privacidad de los datos es crucial, como el sector de la salud, la banca y cualquier sistema donde los usuarios deban autenticar su identidad para acceder a servicios.&lt;/p&gt;
&lt;h2 id="configuración-de-keystores-y-truststores"&gt;Configuración de KeyStores y TrustStores
&lt;/h2&gt;&lt;p&gt;Para implementar la seguridad mediante TLS, fue necesario configurar tanto el almacén de claves (KeyStore) como el almacén de certificados (TrustStore). Estos elementos permiten la autenticación mutua entre el cliente y el servidor. El KeyStore contiene las claves privadas y los certificados asociados que identifican a la entidad (cliente o servidor), mientras que el TrustStore gestiona los certificados de las entidades de confianza, permitiendo validar que las contrapartes de la comunicación son legítimas.&lt;/p&gt;
&lt;p&gt;En el desarrollo de este proyecto, se utilizó Keytool, una herramienta incluida en el JDK de &lt;strong&gt;Java&lt;/strong&gt;, para crear y gestionar los certificados. El proceso requirió la configuración de las variables de entorno como JAVA_HOME y PATH, para facilitar el uso de esta herramienta desde la línea de comandos.&lt;/p&gt;
&lt;h2 id="implementación-de-sockets-tls"&gt;Implementación de Sockets TLS
&lt;/h2&gt;&lt;p&gt;La comunicación entre el cliente y el servidor se realizó mediante sockets SSL (Secure Sockets Layer), sobre los cuales se integró el protocolo TLS. En ambos extremos, cliente y servidor, se configuraron sockets seguros que permitían la transmisión de datos encriptados. El servidor estaba diseñado para escuchar conexiones entrantes en un puerto específico (en este caso, el puerto 3343), autenticando a los clientes mediante la verificación de sus credenciales.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Servidor TLS&lt;/strong&gt;: El servidor se encargaba de recibir las conexiones de los clientes y autenticar a cada usuario mediante la verificación de sus credenciales (nombre de usuario y contraseña). Además, proporcionaba respuestas basadas en el resultado de esta verificación, informando al cliente si la autenticación había sido exitosa o fallida.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cliente TLS&lt;/strong&gt;: El cliente establecía una conexión segura con el servidor y enviaba las credenciales del usuario para su verificación. La respuesta del servidor se mostraba en una interfaz de usuario sencilla, indicando si el proceso de autenticación había sido exitoso o si hubo algún error.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="pruebas-de-comunicación-y-seguridad"&gt;Pruebas de Comunicación y Seguridad
&lt;/h2&gt;&lt;p&gt;Se realizaron pruebas de comunicación tanto con seguridad como sin ella, con el fin de destacar la importancia del uso de TLS en aplicaciones que manejan información sensible. Para las pruebas sin seguridad, se implementó un socket sin cifrado que permitía observar cómo un atacante, usando herramientas como &lt;strong&gt;Wireshark&lt;/strong&gt;, podía capturar y visualizar en texto claro las credenciales de usuario transmitidas.&lt;/p&gt;
&lt;p&gt;En contraste, al habilitar TLS, se observó cómo toda la información transmitida se encontraba encriptada, imposibilitando que un atacante pudiera leer los datos capturados en la red. Esto demostró la efectividad de TLS para proteger la confidencialidad y la integridad de la información.&lt;/p&gt;
&lt;h2 id="rendimiento-y-concurrencia"&gt;Rendimiento y Concurrencia
&lt;/h2&gt;&lt;p&gt;Un aspecto clave de este proyecto fue la validación del rendimiento del sistema, específicamente la capacidad de manejar múltiples conexiones concurrentes. El servidor fue configurado para gestionar hasta 300 conexiones simultáneas, lo cual fue logrado utilizando hilos (threads) en Java para manejar las solicitudes en paralelo. A pesar de que las conexiones se realizaban de forma secuencial en las pruebas iniciales (una cada segundo), el sistema demostró ser robusto al procesar las peticiones de forma eficiente sin comprometer la seguridad o la estabilidad.&lt;/p&gt;
&lt;p&gt;Documentación del proyecto: &lt;a class="link" href="../../../post/seguridad-gasca/conexion_TLS.pdf" &gt;&lt;strong&gt;Visualizar documentación en pdf&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>