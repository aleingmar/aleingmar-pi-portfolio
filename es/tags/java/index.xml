<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Alejandro Inglés Martínez</title><link>https://aleingmar-pi-portfolio.duckdns.org/es/tags/java/</link><description>Recent content in Java on Alejandro Inglés Martínez</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Wed, 01 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://aleingmar-pi-portfolio.duckdns.org/es/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Implementación de una Arquitectura Segura Cliente-Servidor en Java utilizando TLS</title><link>https://aleingmar-pi-portfolio.duckdns.org/es/p/seguridad-gasca/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://aleingmar-pi-portfolio.duckdns.org/es/p/seguridad-gasca/</guid><description>&lt;img src="https://aleingmar-pi-portfolio.duckdns.org/p/security-gasca/java3.png" alt="Featured image of post Implementación de una Arquitectura Segura Cliente-Servidor en Java utilizando TLS" /&gt;&lt;p&gt;Este proyecto fue desarrollado durante la asignatura de Seguridad, Confidencialidad y Gestión de la Identidad (SCGI) durante mi tercer año de carrera. Este proyecto se centró en el diseño y desarrollo de una arquitectura cliente-servidor segura utilizando el protocolo Transport Layer Security (TLS), con el objetivo de asegurar la confidencialidad, integridad y autenticidad de las comunicaciones.&lt;/p&gt;
&lt;h2 id="contexto-y-objetivo"&gt;Contexto y Objetivo
&lt;/h2&gt;&lt;p&gt;El proyecto surgió de la necesidad de asegurar las comunicaciones en una aplicación que permitiera la transmisión de datos sensibles, como credenciales de usuario (login/password), entre clientes y un servidor central. Este tipo de aplicaciones es especialmente relevante en entornos donde la privacidad de los datos es crucial, como el sector de la salud, la banca y cualquier sistema donde los usuarios deban autenticar su identidad para acceder a servicios.&lt;/p&gt;
&lt;h2 id="configuración-de-keystores-y-truststores"&gt;Configuración de KeyStores y TrustStores
&lt;/h2&gt;&lt;p&gt;Para implementar la seguridad mediante TLS, fue necesario configurar tanto el almacén de claves (KeyStore) como el almacén de certificados (TrustStore). Estos elementos permiten la autenticación mutua entre el cliente y el servidor. El KeyStore contiene las claves privadas y los certificados asociados que identifican a la entidad (cliente o servidor), mientras que el TrustStore gestiona los certificados de las entidades de confianza, permitiendo validar que las contrapartes de la comunicación son legítimas.&lt;/p&gt;
&lt;p&gt;En el desarrollo de este proyecto, se utilizó Keytool, una herramienta incluida en el JDK de &lt;strong&gt;Java&lt;/strong&gt;, para crear y gestionar los certificados. El proceso requirió la configuración de las variables de entorno como JAVA_HOME y PATH, para facilitar el uso de esta herramienta desde la línea de comandos.&lt;/p&gt;
&lt;h2 id="implementación-de-sockets-tls"&gt;Implementación de Sockets TLS
&lt;/h2&gt;&lt;p&gt;La comunicación entre el cliente y el servidor se realizó mediante sockets SSL (Secure Sockets Layer), sobre los cuales se integró el protocolo TLS. En ambos extremos, cliente y servidor, se configuraron sockets seguros que permitían la transmisión de datos encriptados. El servidor estaba diseñado para escuchar conexiones entrantes en un puerto específico (en este caso, el puerto 3343), autenticando a los clientes mediante la verificación de sus credenciales.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Servidor TLS&lt;/strong&gt;: El servidor se encargaba de recibir las conexiones de los clientes y autenticar a cada usuario mediante la verificación de sus credenciales (nombre de usuario y contraseña). Además, proporcionaba respuestas basadas en el resultado de esta verificación, informando al cliente si la autenticación había sido exitosa o fallida.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cliente TLS&lt;/strong&gt;: El cliente establecía una conexión segura con el servidor y enviaba las credenciales del usuario para su verificación. La respuesta del servidor se mostraba en una interfaz de usuario sencilla, indicando si el proceso de autenticación había sido exitoso o si hubo algún error.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="pruebas-de-comunicación-y-seguridad"&gt;Pruebas de Comunicación y Seguridad
&lt;/h2&gt;&lt;p&gt;Se realizaron pruebas de comunicación tanto con seguridad como sin ella, con el fin de destacar la importancia del uso de TLS en aplicaciones que manejan información sensible. Para las pruebas sin seguridad, se implementó un socket sin cifrado que permitía observar cómo un atacante, usando herramientas como &lt;strong&gt;Wireshark&lt;/strong&gt;, podía capturar y visualizar en texto claro las credenciales de usuario transmitidas.&lt;/p&gt;
&lt;p&gt;En contraste, al habilitar TLS, se observó cómo toda la información transmitida se encontraba encriptada, imposibilitando que un atacante pudiera leer los datos capturados en la red. Esto demostró la efectividad de TLS para proteger la confidencialidad y la integridad de la información.&lt;/p&gt;
&lt;h2 id="rendimiento-y-concurrencia"&gt;Rendimiento y Concurrencia
&lt;/h2&gt;&lt;p&gt;Un aspecto clave de este proyecto fue la validación del rendimiento del sistema, específicamente la capacidad de manejar múltiples conexiones concurrentes. El servidor fue configurado para gestionar hasta 300 conexiones simultáneas, lo cual fue logrado utilizando hilos (threads) en Java para manejar las solicitudes en paralelo. A pesar de que las conexiones se realizaban de forma secuencial en las pruebas iniciales (una cada segundo), el sistema demostró ser robusto al procesar las peticiones de forma eficiente sin comprometer la seguridad o la estabilidad.&lt;/p&gt;
&lt;p&gt;Documentación del proyecto: &lt;a class="link" href="../../../post/seguridad-gasca/conexion_TLS.pdf" &gt;&lt;strong&gt;Visualizar documentación en pdf&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>